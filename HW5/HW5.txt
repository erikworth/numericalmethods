1.

Code:

#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>

int main()
{
	
	int i, j, N = 10000, M = 100000;
	double x[N], X[M], X1, X2, X3, X4, X5, X6;
	
	srand(time(NULL));
	
	X1 = 0, X2 = 0, X3 = 0, X4 = 0, X5 = 0, X6 = 0;
	
	for (j = 0; j < M; j++)
	{
		for (i = 0; i < N; i++)
		{
			x[i] = rand()/(double)RAND_MAX;
			X[j] += x[i] - 0.5;
		}
	
	
		X[j] *= sqrt(12.0/N);
		X1 = X1 + X[j];
		X2 = X2 + X[j]*X[j];
		X3 = X3 + pow(X[j], 3);
		X4 = X4 + pow(X[j], 4);
		X5 = X5 + pow(X[j], 5);
		X6 = X6 + pow(X[j], 6);
	}
	
	
	X1 = X1/M;
	X2 = X2/M;
	X3 = X3/M;
	X4 = X4/M;
	X5 = X5/M;
	X6 = X6/M;
	printf("X1 = %f\n", X1);
	printf("X2 = %f\n", X2);
	printf("X3 = %f\n", X3);
	printf("X4 = %f\n", X4);
	printf("X5 = %f\n", X5);
	printf("X6 = %f\n", X6);

}

Output:

X1 = 0.004896
X2 = 1.002549
X3 = 0.013583
X4 = 3.024584
X5 = 0.036742
X6 = 15.332342

Explanation:

Arrays x[N] and X[M] are initialized, where x[i]s are the random numbers and
X[j]s are the sums of the random numbers. Then the X[j]s are all multiplied
by the normalization of the distribution, sqrt(12/N), and the sums of the
first 6 powers of the X[j]s are kept in variables X1 through X6, representing
the first 6 moments. After the for loops have finished, X1 through X6 are 
divided by M, the number of X[j]s to compute the final moments. These are 
then printed in a series of print statements. With N = 10000 and M = 100000
the moments are as we would expect from a Gaussian distribution, with
X1, X3 and X5 all nearly 0, X4 nearly 3, and X6 close to 15.

2.

Code:

#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>
#define pi 3.14159265358979323846

int main()
{
	int sum, i, N = 1000000;
	double u, x[N];
	
	srand(time(NULL));
	
	for (i = 0; i < N; i++)
	{
		u = rand()/(double)RAND_MAX;
		x[i] = tan(pi*(u - 0.5));
		if (fabs(x[i]) < 1) sum++;
	}
	
	printf("The fraction of x with |x| < 1 is %f\n", (double)sum/N);
}

Output:

The fraction of x with |x| < 1 is 0.498880

Explanation:

In a for loop, u is assigned a random number between 0 and 1 from a uniform
distribution, and the elements of the array x[i] are assigned to 
tan(pi*(u - 0.5)). For each x[i], if |X| < 1 the variable sum is incremented 
by 1. At the end of the program a print statement computes the fraction of
sum divided by the total number of elements.

3.

Code:

#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>


double f(double x) // define function to be integrated
{
	return log(x);
}

main()
{
	double x, a, b, fav, f2av, err, exact, nsigma;
	int i, N = 10000;
	
 	exact = log(4) - 1;
 	b = 2.0; // set upper limit
 	a = 1.0; // set lower limit
 	srand(time(NULL)); // initialize RNG
 	printf (" \tx \t  f(x)   f^2(x)\n");
 	fav = 0; f2av = 0;
 	
	for (i = 0; i < N; i++)
 	{
		x = a + (b - a) * rand() / RAND_MAX; //random value for x
		fav += f(x); // compute f(x)
		f2av += f(x)*f(x); // compute f(x)^2
		printf ("%10.5f %10.5f %10.5f \n", x, f(x), f(x)*f(x));
 	}
 	
 	fav /= N; // sample average of f
 	f2av /= N; // sample average of f^2
 	err = sqrt((f2av - fav*fav) / (N - 1)); // error bar
 	printf ("\n answer = %10.5f \n", (b - a) * fav);
 	printf (" error bar = %10.5f \n", (b - a) * err);
 	nsigma = (fav - exact) / err; // no of st.devs. from exact
 	printf ("\n answer is %10.3f sigma away from exact value \n", nsigma);
}

Output:

 	x 	 f(x)     f^2(x)
   1.53475    0.42836    0.18350 
   1.80755    0.59197    0.35043 
   1.38945    0.32891    0.10818 
...
   1.64882    0.50006    0.25006 
   1.51418    0.41487    0.17212 
   1.65380    0.50307    0.25308 


 answer =    0.38614 
 error bar =    0.00199 

 answer is     -0.075 sigma away from exact value 

Explanation:

mcint.c was used to carry out the integration. f() was taken to be
log(x), and analytically solving the integral gives the answer ln(4) - 1.
With N taken to be 10000, the program's result (0.38614 ± 0.00199) lies
within 0.075 standard deviations from the exact answer, well within the
68% probability region of the Gaussian distribution.

4.

Code:

#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>


double f(double x[])
{
	double a;
	
	a = x[0] + x[1] + x[2]+ x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9];
	return pow(a, 2);
}

main()
{
	double x[10], a, b, fav, f2av, err, exact, nsigma;
	int i, j, N = 10000;
 	exact = 155.0/6;
 	b = 1; // set upper limit
 	a = 0; // set lower limit
 	srand(time(NULL)); // initialize RNG
 	fav = 0; f2av = 0;
 	
	for (i = 0; i < N; i++)
 	{
 		for (j = 0; j < 10; j++)
 		{
 			x[j] = a + (b - a) * rand()/RAND_MAX; //random values for x[j]s
 		}
		fav += f(x); // compute f(x)
		f2av += f(x)*f(x); // compute f(x)^2
 	}
 	
 	fav /= N; // sample average of f
 	f2av /= N; // sample average of f^2
 	err = sqrt((f2av - fav*fav) / (N - 1)); // error bar
 	printf ("\n answer = %10.5f \n", (b - a) * fav);
 	printf (" error bar = %10.5f \n", (b - a) * err);
 	nsigma = (fav - exact) / err; // no of st.devs. from exact
 	printf ("\n answer is %10.3f sigma away from exact value \n", nsigma);
}

Output:


 answer =   25.91585 
 error bar =    0.09185 

 answer is      0.898 sigma away from exact value 

Explanation:

The function f() takes a double array x[], sums the first ten elements of x[],
and squares the result. The main program assigns a random number between 1 and
2 to each element of x[], then running averages of f() and f()*f() are stored
in fav and f2av. The averages are computed after N iterations by dividing by N.
The answer is computed to be 25.91585 ± 0.09185, which is about 0.9 standard
deviations away from the exact value of 155/6.

5.

Code:

#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

int main()
{
	int step, t, tmax, x, i, N = 400;
	double xrand, xave[N], x2ave[N];
	double rxave, rx2ave, sum, sum2;
	
	tmax = 100;
	
	srand(time(NULL));
	
	
	for (i = 0; i < N; i++)
	{
		x = 0;
		for (t = 1; t < tmax + 1; t++)
		{
			xrand = (double)rand()/RAND_MAX;
			if (xrand < 0.5) step = -1;
			else step = 1;
	
			x += step;
			printf("%d\t%d\t%d\n", t, x, x*x);
		}
		
		xave[i] = (double) x/tmax;
		x2ave[i] = (double) x*x/tmax;
		
	}
	
	sum = 0, sum2 = 0;
	
	for (i = 0; i < N; i++)
	{
		sum += xave[i];
		sum2 += x2ave[i];
		if ( i == 0)
		{
			rxave = sum;
			rx2ave = sum2;
		}
		else
		{
			rxave = sum/(double)i;
			rx2ave = sum2/(double)i;
		}
		//printf("%f\t%f\n", rxave, rx2ave);
	}
}

Output:

t	x	x^2
1	-1	1
2	-2	4
3	-1	1
...
98	-8	64
99	-9	81
100	-10	100

xave		x2ave
0.100000	1.000000
-0.080000	4.240000
-0.110000	3.100000
-0.080000	2.080000
-0.050000	1.600000
...
0.002980	1.032828
0.003123	1.031134
0.003518	1.034975
0.003258	1.034887

Explanation:

A random number between 0 and 1 is assigned to the variable xrand.
If the value is less than 0.5 the variable step is assigned to -1;
otherwise step is assigned to +1. This is done in a loop, and for each 
loop the value in step is added to x, and t, x, and x^2 are printed each
time. After t reaches tmax x/tmax and x*x/tmax, the time averages of x
and x^2 are stored in an array. This is done N times. Then in a separate
loop the sums of the arrays are stored in sum and sum2 and running averages
rxave and rx2ave are computed and printed for each iteration. These are
averages over both time and the number of walks. The average of x is close
to 0 and the average of (x^2)/t is nearly 1 as expected.